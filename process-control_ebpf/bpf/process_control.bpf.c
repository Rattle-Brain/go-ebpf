/**
vmlinux.h is autogenerated. Run the following comand in your machine if you want
to use it:

    bpftool btf dump file /sys/kernel/btf/vmlinux format c > user-activity_ebpf/bpf/vmlinux.h

What's vmlinux.h for?
The command generates a vmlinux.h header file with all kernel types (BTF types) that the running kernel uses.
Including vmlinux.h in your BPF program eliminates dependency on system-wide kernel headers.

For more information refer to this page:
https://docs.kernel.org/bpf/libbpf/libbpf_overview.html
*/

#include "vmlinux.h"

#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>
#include <sys/cdefs.h>


#define MAX_ENTRIES 1024
#define COMM_NAME_LEN 32

#define LAST_32BITS(x) x >> 32


struct event {
    u32 ppid;
    u32 puid;
    u32 pgid;
    u32 pid;
    u32 uid;
    u32 gid;
    char comm[TASK_COMM_LEN];
    char parent_comm[TASK_COMM_LEN];
    char action;
};

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(max_entries, MAX_ENTRIES);
    __type(key, u32);
    __type(value, u32);
} events SEC(".maps");

static __always_inline void fill_event(struct event *event, struct task_struct *task) {
    if(event && task){
        // Process info
        bpf_probe_read_kernel(&event->pid, sizeof(event->pid), &task->pid);
        bpf_get_current_comm(&event->comm, sizeof(event->comm));
        
        // Credentials task info
        struct cred *task_cred;
        bpf_probe_read_kernel(&task_cred, sizeof(&task_cred), &task->cred);
        bpf_probe_read_kernel(&event->uid, sizeof(event->uid), &task_cred->uid.val);
        bpf_probe_read_kernel(&event->gid, sizeof(event->gid), &task_cred->gid.val);

        // Parent process info
        struct task_struct *real_parent;
        bpf_probe_read_kernel(&real_parent, sizeof(&real_parent), &task->real_parent);
        bpf_probe_read_kernel(&event->ppid, sizeof(event->ppid), &real_parent->pid);
        bpf_probe_read_kernel(&event->parent_comm, sizeof(event->parent_comm), real_parent->comm);

        // We need another cred struct to store info from the real_parent_task so we reuse the previous one
        bpf_probe_read_kernel(&task_cred, sizeof(&task_cred), &real_parent->cred);
        bpf_probe_read_kernel(&event->puid, sizeof(event->puid), &task_cred->uid.val);
        bpf_probe_read_kernel(&event->pgid, sizeof(event->pgid), &task_cred->gid.val);
    }
}

static __always_inline int send_event_to_map(struct trace_event_raw_sys_enter *ctx, char action){
    struct event event = {};
    struct task_struct *task = (struct task_struct *)bpf_get_current_task();

    fill_event(&event, task);

    // Add the action code to the event struct
    __builtin_memcpy(&event.action, &action, sizeof(char));

    // Let's check if the parent_task and current_task differ in privileges
    if((event.puid != event.uid || event.pgid != event.gid) && event.uid != 1001){
        bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof(event));
    }
    return 0;
}

SEC("tracepoint/syscalls/sys_enter_execve")
int trace_execve(struct trace_event_raw_sys_enter *ctx) {
    return send_event_to_map(ctx, 'e');
}


SEC("tracepoint/syscalls/sys_enter_fork")
int trace_fork(struct trace_event_raw_sys_enter *ctx) {
    return send_event_to_map(ctx, 'f');
}


SEC("tracepoint/syscalls/sys_enter_clone")
int trace_clone(struct trace_event_raw_sys_enter *ctx) {
    return send_event_to_map(ctx, 'c');
}

char LICENSE[] SEC("license") = "GPL";