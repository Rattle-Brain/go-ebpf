/**
vmlinux.h is autogenerated. Run the following comand in your machine if you want
to use it:

    bpftool btf dump file /sys/kernel/btf/vmlinux format c > user-activity_ebpf/bpf/vmlinux.h

What's vmlinux.h for?
The command generates a vmlinux.h header file with all kernel types (BTF types) that the running kernel uses.
Including vmlinux.h in your BPF program eliminates dependency on system-wide kernel headers.

For more information refer to this page:
https://docs.kernel.org/bpf/libbpf/libbpf_overview.html
*/

#include "vmlinux.h"

#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>
#include <sys/cdefs.h>


#define MAX_ENTRIES 1024

#define LAST_32BITS(x) x >> 32


struct event {
    u32 pid;
    u32 ppid;
    u32 uid;
    u32 gid;
    char comm[TASK_COMM_LEN];
    char parent_comm[TASK_COMM_LEN];
    char action;
};

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(max_entries, MAX_ENTRIES);
    __type(key, u32);
    __type(value, u32);
} events SEC(".maps");

static __always_inline void fill_event(struct event *event, struct task_struct *task) {
    if(event && task){
        bpf_probe_read_kernel(&event->pid, sizeof(event->pid), &task->pid);
        bpf_probe_read_kernel(&event->pid, sizeof(event->ppid), &task->real_parent->pid);
        bpf_probe_read_kernel(&event->uid, sizeof(event->uid), &task->cred->uid.val);
        bpf_probe_read_kernel(&event->gid, sizeof(event->gid), &task->cred->gid.val);
        bpf_get_current_comm(&event->comm, sizeof(event->comm));
        bpf_probe_read_kernel(&event->parent_comm, sizeof(event->parent_comm), task->real_parent->comm);
    }
}

static __always_inline int send_event_to_map(struct trace_event_raw_sys_enter *ctx, char action){
    struct event event = {};
    struct task_struct *task = (struct task_struct *)bpf_get_current_task();

    fill_event(&event, task);

    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &event, sizeof(event));
    return 0;
}

SEC("tracepoint/syscalls/sys_enter_execve")
int trace_execve(struct trace_event_raw_sys_enter *ctx) {
    return send_event_to_map(ctx, 'e');
}


SEC("tracepoint/syscalls/sys_enter_fork")
int trace_fork(struct trace_event_raw_sys_enter *ctx) {
    return send_event_to_map(ctx, 'f');
}


SEC("tracepoint/syscalls/sys_enter_clone")
int trace_clone(struct trace_event_raw_sys_enter *ctx) {
    return send_event_to_map(ctx, 'c');
}

char LICENSE[] SEC("license") = "GPL";