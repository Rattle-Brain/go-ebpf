/**
vmlinux.h is autogenerated. Run the following comand in your machine if you want
to use it:

    bpftool btf dump file /sys/kernel/btf/vmlinux format c > sra-monitor_ebpf/bpf/vmlinux.h

What's vmlinux.h for?
The command generates a vmlinux.h header file with all kernel types (BTF types) that the running kernel uses.
Including vmlinux.h in your BPF program eliminates dependency on system-wide kernel headers.

For more information refer to this page:
https://docs.kernel.org/bpf/libbpf/libbpf_overview.html
*/
#include "vmlinux.h"

#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


#define LEN_FILENAME 128
#define LEN_COMM 16

#define MAX_ENTRIES 1024

// Macro that allows to obtain the PID
#define GETPID(x) x >> 32

// Struct containing all relevant information about the syscall event
struct write_event_data {
    char syscall;
    u32 pid;
    u32 uid;
    char comm[LEN_COMM];
    u64 fd;
    u64 ts_enter;
    u64 ts_exit;
    s32 ret;
};

// Perf map to store events (data_enter/data_exit)
struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(max_entries, MAX_ENTRIES);
    __type(key, u32);
    __type(value, u32);
} file_event_map SEC(".maps");

// Temporary event storage
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, MAX_ENTRIES);
    __type(key, u64);
    __type(value, struct write_event_data);
} temp_mem SEC(".maps");

// Entry arguments. 
// Documentation in /sys/kernel/tracing/events/syscalls/sys_enter_write
struct entry_args_t {
    char _padding1[16];

    unsigned int fd;
    const char * buf;
    size_t count;
};

// Exit arguments. 
// Documentation in /sys/kernel/tracing/events/syscalls/sys_exit_write
struct exit_args_t {
    char _padding1[16];

    s64 ret;
};

SEC("tracepoint/syscalls/sys_enter_write")
int tracepoint_enter_write(struct entry_args_t *ctx) {
    struct write_event_data dat = {};
    int err;

    // Add a char to identify the syscall name on the userspace
    dat.syscall = 'w';

    // Extract PID and UID
    u64 pid_tgid = bpf_get_current_pid_tgid(); // we need this as key
    dat.pid = GETPID(pid_tgid);
    dat.uid = bpf_get_current_uid_gid();

    // Get a "enter" timestamp
    dat.ts_enter = bpf_ktime_get_ns();

    // Get the process that called the sys_open syscall
    err = bpf_get_current_comm(&dat.comm, LEN_COMM);
    if(err < 0){
        bpf_printk("Error getting exec name\n");
        return err;
    }

    /* 
    This time, instead of the filename, we save the file descriptor
    Why? Because sys_enter_write does not store the filename, stores the fd
    and I'm NOT recompiling the kernel to add the bpf_fd2path helper function
    when I can fetch the filename from the fd in the userspace.

    There's a chance I do this for all tracepoints for many reasons I'm not explaining here
    */
    dat.fd = ctx->fd;

    // We save this information for later use (complete with retval)
    err = bpf_map_update_elem(&temp_mem, &pid_tgid, &dat, BPF_ANY);
    if(err < 0){
        bpf_printk("Error saving event to temp_mem\n");
        return err;
    }

    return 0;
}

SEC("tracepoint/syscalls/sys_exit_write")
int trace_exit_write(struct exit_args_t *ctx){
    u64 pid_tgid = bpf_get_current_pid_tgid();
    struct write_event_data *dat = bpf_map_lookup_elem(&temp_mem, &pid_tgid);

    if(dat){
        // Fill up the rest of fields
        dat->ts_exit = bpf_ktime_get_ns();  // So we know the time it took to complete the syscall
        dat->ret = ctx->ret;

        // Now let's output the struct to the map
        bpf_perf_event_output(ctx, &file_event_map, BPF_F_CURRENT_CPU, dat, sizeof(*dat));

        // And delete event from temp to avoid key colisions
        bpf_map_delete_elem(&temp_mem, &pid_tgid);
    }

    return 0;
}

char _license[] SEC("license") = "GPL";