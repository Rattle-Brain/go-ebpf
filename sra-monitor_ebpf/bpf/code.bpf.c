/**
vmlinux.h is autogenerated. Run the following comand in your machine if you want
to use it:

    bpftool btf dump file /sys/kernel/btf/vmlinux format c > sra-monitor_ebpf/bpf/vmlinux.h
*/
#include "vmlinux.h"

#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

#define LEN_FILENAME 64
#define LEN_COMM 16

// Macro that allows to obtain the PID
#define GETPID(x) x >> 32

// Stores entering syscall data
struct data_enter {
    u32 pid;
    u32 uid;
    char comm[LEN_COMM];
    char filename[LEN_FILENAME];
    u64 timestamp;
};

// Stores exitting syscall data
struct data_exit {
    u32 pid;
    u32 uid;
    char comm[LEN_COMM];
    u64 timestamp;
    u64 ret_value;  // Return value
};

// Perf map to store events (data_enter/data_exit)
struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
} file_event_map SEC(".maps");

SEC("tracepoint/syscalls/sys_enter_open")
int trace_enter_open(struct pt_regs *ctx) {
    struct data_enter dat = {};

    // Extract PID, UID and timestamp
    dat.pid = GETPID(bpf_get_current_pid_tgid());
    dat.uid = bpf_get_current_uid_gid();
    dat.timestamp = bpf_ktime_get_ns();

    // Get the process that called the sys_open syscall
    bpf_get_current_comm(&dat.comm, sizeof(dat.comm));

    // Get the filename that was accessed
    bpf_probe_read_user_str(&dat.filename, sizeof(dat.filename), (void *)PT_REGS_PARM1(ctx));

    // Output contents to perfmap
    bpf_perf_event_output(ctx, &file_event_map, BPF_F_CURRENT_CPU, &dat, sizeof(dat));

    return 0;
}

SEC("tracepoint/syscalls/sys_exit_open")
int trace_exit_open(struct pt_regs *ctx){
    struct data_exit dat= {};

    // Extract PID, UID and timestamp
    dat.pid = GETPID(bpf_get_current_pid_tgid());
    dat.uid = bpf_get_current_uid_gid();
    dat.timestamp = bpf_ktime_get_ns();

    // Get the process that called the sys_open syscall
    bpf_get_current_comm(&dat.comm, sizeof(dat.comm));

    // Extract the return value form *ctx
    dat.ret_value = PT_REGS_RC(ctx);

    // Output contents to perfmap
    bpf_perf_event_output(ctx, &file_event_map, BPF_F_CURRENT_CPU, &dat, sizeof(dat));
    
    return 0;
}


SEC("tracepoints/syscalls/sys_enter_read")
int trace_enter_read(struct pt_regs *ctx) {
    struct data_enter dat = {};

    // Extract PID, UID and timestamp
    dat.pid = GETPID(bpf_get_current_pid_tgid());
    dat.uid = bpf_get_current_uid_gid();
    dat.timestamp = bpf_ktime_get_ns();

    // Get the process that called the sys_open syscall
    bpf_get_current_comm(&dat.comm, sizeof(dat.comm));

    // Get the filename that was accessed
    bpf_probe_read_user_str(&dat.filename, sizeof(dat.filename), (void *)PT_REGS_PARM1(ctx));

    // Output contents to perfmap
    bpf_perf_event_output(ctx, &file_event_map, BPF_F_CURRENT_CPU, &dat, sizeof(dat));

    return 0;
}

SEC("tracepoint/syscalls/sys_exit_read")
int trace_exit_read(struct pt_regs *ctx){
    struct data_exit dat= {};

    // Extract PID, UID and timestamp
    dat.pid = GETPID(bpf_get_current_pid_tgid());
    dat.uid = bpf_get_current_uid_gid();
    dat.timestamp = bpf_ktime_get_ns();

    // Get the process that called the sys_open syscall
    bpf_get_current_comm(&dat.comm, sizeof(dat.comm));

    // Extract the return value form *ctx
    dat.ret_value = PT_REGS_RC(ctx);

    // Output contents to perfmap
    bpf_perf_event_output(ctx, &file_event_map, BPF_F_CURRENT_CPU, &dat, sizeof(dat));
    
    return 0;
}


SEC("tracepoints/syscalls/sys_enter_write")
int tracepoint_enter_write(struct pt_regs *ctx) {
    struct data_enter dat = {};

    // Extract PID, UID and timestamp
    dat.pid = GETPID(bpf_get_current_pid_tgid());
    dat.uid = bpf_get_current_uid_gid();
    dat.timestamp = bpf_ktime_get_ns();

    // Get the process that called the sys_open syscall
    bpf_get_current_comm(&dat.comm, sizeof(dat.comm));

    // Get the filename that was accessed
    bpf_probe_read_user_str(&dat.filename, sizeof(dat.filename), (void *)PT_REGS_PARM1(ctx));

    // Output contents to perfmap
    bpf_perf_event_output(ctx, &file_event_map, BPF_F_CURRENT_CPU, &dat, sizeof(dat));

    return 0;
}

SEC("tracepoint/syscalls/sys_exit_write")
int trace_exit_write(struct pt_regs *ctx){
    struct data_exit dat= {};

    // Extract PID, UID and timestamp
    dat.pid = GETPID(bpf_get_current_pid_tgid());
    dat.uid = bpf_get_current_uid_gid();
    dat.timestamp = bpf_ktime_get_ns();

    // Get the process that called the sys_open syscall
    bpf_get_current_comm(&dat.comm, sizeof(dat.comm));

    // Extract the return value form *ctx
    dat.ret_value = PT_REGS_RC(ctx);

    // Output contents to perfmap
    bpf_perf_event_output(ctx, &file_event_map, BPF_F_CURRENT_CPU, &dat, sizeof(dat));
    
    return 0;
}

/*
Cool original idea but ingored for the moment.
*****************************************************
SEC("kprobe/sys_rename")
int kprobe_sys_rename(struct pt_regs *ctx) {
    // Extract relevant information and process it
    return 0;
}

SEC("kprobe/sys_unlink")
int kprobe_sys_unlink(struct pt_regs *ctx) {
    // Extract relevant information and process it
    return 0;
}
*/

char _license[] SEC("license") = "GPL";