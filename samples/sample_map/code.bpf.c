/**
vmlinux.h is autogenerated. Run the following comand in your machine if you want
to use it:

    bpftool btf dump file /sys/kernel/btf/vmlinux format c > sra-monitor_ebpf/bpf/vmlinux.h

What's vmlinux.h for?
The command generates a vmlinux.h header file with all kernel types (BTF types) that the running kernel uses.
Including vmlinux.h in your BPF program eliminates dependency on system-wide kernel headers.

For more information refer to this page:
https://docs.kernel.org/bpf/libbpf/libbpf_overview.html
*/
#include "vmlinux.h"

#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


#define MAX_ENTRIES 1024

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(max_entries, MAX_ENTRIES);
    __type(key, u32);           // type u32 defined in vmlinux.h
    __type(value, umode_t);     // type umode_t defined in vmlinux.h
} file_event_map SEC(".maps");

struct entry_args_t {
    char _padding1[24];

    const char* filename;
    int flags;
    umode_t mode;
};

SEC("tracepoint/syscalls/sys_enter_openat")
int trace_enter_open(struct entry_args_t *ctx) {

    // Get the file descriptor from the map
    // We assume this map stores the flags for the openat syscall
    umode_t* mode = bpf_map_lookup_elem(&file_event_map, &ctx->flags);
    if (mode == NULL) {
        bpf_printk("Error looking up file descriptor\n");
        return -1;
    }

    // Now we can modify the mode to our liking
    // this is just an example and performs no real action
    *mode = 0;
    int err = bpf_map_update_elem(&file_event_map, &ctx->flags, mode, BPF_ANY);
    if (err < 0) {
        bpf_printk("Error updating file descriptor\n");
        return -1;
    }
    return 0;

}
// The license is important, don't forget to put it
char _license[] SEC("license") = "GPL";

