//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -target bpfel -cc clang code code.bpf.c  -- -I/usr/include/linux/bpf.h

package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
    "log"
    "os"
    "os/signal"
    "syscall"
    
    "github.com/cilium/ebpf/perf"
    "github.com/cilium/ebpf/link"
)

// execveEvent must match the structure from execve_trace.bpf.c
type execveEvent struct {
    Pid  uint32
    Comm [16]byte
}

func main() {
    // Load the eBPF objects (programs and maps) generated by ebpf2go
    objs := codeObjects{}
    if err := loadCodeObjects(&objs, nil); err != nil {
        log.Fatalf("loading objects: %v", err)
    }
    defer objs.Close()

    // Attach the program to the execve syscall tracepoint
    link, err := link.Tracepoint("syscalls", "sys_enter_execve", objs.codePrograms.TraceExecve, nil)
    if err != nil {
        log.Fatalf("Failed to attach tracepoint: %v", err)
    }
    defer link.Close()

    // Create a perf event reader to read events from the execve_events map
    reader, err := perf.NewReader(objs.ExecveEvents, 4096)
    if err != nil {
        log.Fatalf("Failed to create perf event reader: %v", err)
    }
    defer reader.Close()

    // Set up signal handling to clean up on exit
    sigs := make(chan os.Signal, 1)
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
    go func() {
        <-sigs
        fmt.Println("Exiting...")
        os.Exit(0)
    }()

    // Read events from the perf event reader
    for {
        record, err := reader.Read()
        if err != nil {
            log.Fatalf("Failed to read from perf event reader: %v", err)
        }

        // Decode the event data
        var event execveEvent
        err = binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &event)
        if err != nil {
            log.Fatalf("Failed to decode event: %v", err)
        }

        // Show proof the program is working correctly
        fmt.Printf("Hello, World! Execv call executed!\n")
    }
}

